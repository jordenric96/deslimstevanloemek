<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trivial time - Quiz</title>

    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="stijl.css">

</head>
<body>

    <div id="game-over-overlay">
        <h2 id="game-over-subtitle">De slimste mens ter wereld is voor nu:</h2>
        <h1 id="game-over-text">WINNAAR!</h1>
    </div>


    <h1>Trivial time</h1>


    <div id="setup-screen" class="visible">

        <h2>Spelers Instellen</h2>


        <div class="setup-input-row" id="theme-selector-container">

            <label for="theme-select" id="theme-selector-label">Kies Thema:</label>

            <select id="theme-select" style="display: none;"></select>

            <p style="grid-column: 2 / span 2; font-weight: bold; color: var(--secondary-color);">STANDAARD Thema (Vaste Selectie)</p>

        </div>


        <div class="setup-input-row">

            <label for="num-players">Aantal spelers (1-6):</label>

            <input type="number" id="num-players" min="1" max="6" value="4" onchange="updatePlayerInputs()">

        </div>

        <div id="player-name-inputs">

            </div>

        <button id="start-quiz-btn" onclick="initializeGame(1)">Start Quiz</button>

    </div>


    <div id="player-container" style="display: none;">

    </div>


    <div id="game-board" style="display: none;">

        <h2 id="round-title"></h2> <p id="question-counter"></p>


        <p id="question-id"></p>


        <div id="question-area">

            <p id="puzzle-ids"></p>


            <p id="question-text" style="display: none;">Vraagtekst</p>


            <div id="puzzle-display-area" style="display: none;">

                <div id="puzzle-answers-container"></div>

                <div id="puzzle-clues-container"></div>

            </div>


            <div id="opendeur-display-area" style="display: none;">

                <h3 id="opendeur-subject"></h3>

                <div id="opendeur-keywords-container"></div>

            </div>


            <div id="geheugen-display-area" style="display: none;">

                <ul id="geheugen-board"></ul>

            </div>






            <div id="finale-display-area" style="display: none;">

                <h3 id="finale-subject"></h3>

                <div id="finale-keywords-container"></div>

            </div>


            <div class="controls-r2-input-group">

                <input type="text" id="answer-input" placeholder="Typ hier het antwoord in..." style="display: none;">

                <button id="check-answer" style="display: none;">Check Antwoord</button>

            </div>

            </div>


        <div class="controls">

            <button id="start-round-1" style="display: none;">START RONDE 1</button>

            <button id="start-round-2" style="display: none;">Start Ronde 2: Puzzel</button>

            <button id="start-round-3" style="display: none;">Start Ronde 3: Open Deur</button>

            <button id="start-round-4" style="display: none;">Start Ronde 4: Geheugen</button>

            <button id="start-finale" style="display: none;">START DE FINALE</button>


            <button id="next-puzzle" style="display: none;">Volgende Puzzel</button>

            <button id="next-opendeur" style="display: none;">Volgende Vraag</button>


            <button id="next-geheugen-speler" style="display: none;">Volgende Speler</button>



            <button id="show-puzzle-answers" style="display: none;">Toon Puzzel Antwoorden</button>

            <button id="show-opendeur-answers" style="display: none;">Toon Restant</button>

            <button id="show-geheugen-answers" style="display: none;">Toon Alle Antwoorden</button>


            <button id="btn-finale-show" style="display: none;">Toon Antwoorden</button>

            <button id="btn-finale-next" style="display: none;">Volgende Vraag</button>


            </div>


        <hr style="margin-top: 30px; border-color: #555;">


        <div class="player-controls">

            <h3>Spelmeester Controles</h3>

            <p>Klik op de **Spelerkaart** om de klok te starten/stoppen (R2-R5).</p>

            <button id="wrong-answer">Fout Antwoord (-20 sec)</button>

            <button id="add-seconds-10">+10 Seconden</button>

            <button id="add-seconds-20">+20 Seconden</button>

        </div>

    </div>


    <script>

        window.ThemeManager = (function() {

            const THEMES = {};


            function mapData(rawData, name) {

                const mapRound = (pool) => {

                    const poolCopy = JSON.parse(JSON.stringify(pool));

                    return poolCopy.map((item, index) => ({
                        ...item,
                        id: index + 1
                    }));

                };


                const mainData = {

                    themeName: name,

                    ronde1_pool: mapRound(rawData.ronde1_pool),


                    ronde2_answer_pool: mapRound(rawData.ronde2_answer_pool),

                    ronde3_openDeur: mapRound(rawData.ronde3_openDeur).map(q => ({

                        ...q,
                        keywords: q.keywords.map(word => ({ word: (typeof word === 'string' ? word : word.word), found: false }))
                    })),

                    ronde4_geheugen: mapRound(rawData.ronde4_geheugen).map(q => ({

                        q1: q.q1,

                        a: q.a,

                        found: false,

                        id: q.id

                    })),

                    ronde5_finale: mapRound(rawData.ronde5_finale).map(q => ({

                        ...q,

                        keywords: q.keywords.map(word => ({ word: (typeof word === 'string' ? word : word.word), found: false }))

                    }))

                };


                const consoleData = {

                    themeName: name,

                    ronde1_pool: mapRound(rawData.ronde1_pool),

                    ronde2_answer_pool: mapRound(rawData.ronde2_answer_pool),

                    ronde3_openDeur: rawData.ronde3_openDeur,
                    ronde4_geheugen: rawData.ronde4_geheugen,
                    ronde5_finale: rawData.ronde5_finale
                };


                return { main: mainData, console: consoleData };

            }


            return {

                THEMES: THEMES,

                registerTheme: function(name, rawData) {

                    const mapped = mapData(rawData, name);

                    THEMES[name] = mapped;

                },

                getAvailableThemes: function() {

                    return Object.keys(THEMES);

                },

                getActiveTheme: function(name) {

                    const mapped = THEMES['STANDAARD'];

                    return mapped.main;

                }

            };
        })();


        var consoleQuizData = {};

        var mainQuizData = {};

    </script>

    <script src="quizdata_r1.js"></script>
    <script src="quizdata_r2.js"></script>
    <script src="quizdata_r3.js"></script>
    <script src="quizdata_r4.js"></script>
    <script src="quizdata_r5.js"></script>
    <script src="quizdata_loader.js"></script>
    <script>

    let quizData = {};


    // ==========================================================
    // CONFIGURATIE & SPEL LOGICA
    // ==========================================================

    const SIMILARITY_THRESHOLD = 0.80;

    // --- GEWIJZDE CONFIGURATIE VOOR SECONDEN ---
    const R1_BONUS_SECONDS = 20; // NIEUW: 20 seconden
    const R2_R3_R4_BONUS_SECONDS = 40; // NIEUW: 40 seconden
    const R5_OPPONENT_PENALTY_SECONDS = 20; // 20 seconden aftrek bij tegenstander bij JUIST antwoord
    // ------------------------------------------

    function levenshteinDistance(s1, s2) {
        s1 = s1.toLowerCase().trim().replace(/\s/g, "");
        s2 = s2.toLowerCase().trim().replace(/\s/g, "");

        const costs = new Array();
        for (let i = 0; i <= s1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= s2.length; j++) {
                if (i === 0) costs[j] = j;
                else if (j > 0) {
                    let newValue = costs[j - 1];
                    if (s1.charAt(i - 1) !== s2.charAt(j - 1))
                        newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                    costs[j - 1] = lastValue;
                    lastValue = newValue;
                }
            }
            if (i > 0) costs[s2.length] = lastValue;
        }
        return costs[s2.length];
    }

    function stringSimilarity(s1, s2) {
        if (s1.length === 0 && s2.length === 0) return 1.0;

        const longer = s1.length > s2.length ? s1 : s2;
        const shorter = s1.length > s2.length ? s2 : s1;
        const longerLength = longer.length;

        if (longerLength === 0) return 1.0;

        return (longerLength - levenshteinDistance(longer, shorter)) / parseFloat(longerLength);
    }


    function showFinaleWinner(winnerPlayer) {
        stopTimer();
        isGameOver = true;

        document.getElementById('game-over-text').textContent = winnerPlayer.name;
        document.getElementById('game-over-overlay').style.display = 'flex';
    }

    // *** OPTIMALISATIE VOOR BETERE ANIMATIE EN DUIDELIJKHEID ***
    function showBonusFeedback(playerIndex, amount) {
        const playerCard = document.querySelector(`.player-card[data-player-index="${playerIndex}"]`);
        if (!playerCard) return;

        const feedbackEl = playerCard.querySelector('.bonus-feedback');
        if (!feedbackEl) return;

        // Reset de transformatie om de animatie opnieuw te kunnen triggeren
        feedbackEl.style.transition = 'none';
        feedbackEl.style.opacity = '0';
        feedbackEl.style.transform = 'translate(-50%, -50%)'; // Startpositie

        // Dwing reflow/repaint af
        void feedbackEl.offsetWidth; 

        feedbackEl.textContent = `${amount > 0 ? '+' : ''}${amount}`;

        // Pas de kleur aan op basis van winst/verlies
        if (amount > 0) {
            feedbackEl.style.color = 'var(--correct-color)';
            playerCard.classList.add('time-gain-flash');
        } else {
            feedbackEl.style.color = 'var(--wrong-color)';
            // Bij negatief wordt de flash niet gebruikt, maar de kleur is wel belangrijk
            playerCard.classList.add('time-loss-flash'); // NIET BESTAAND IN CSS, MAAR KAN LOKAAL GETEST WORDEN
        }

        // Start de animatie na een kleine vertraging (nodig voor de transition: none reset)
        setTimeout(() => {
            feedbackEl.style.transition = 'transform 1s ease-out, opacity 1s ease-out';
            feedbackEl.style.opacity = '1';
            feedbackEl.style.transform = 'translate(-50%, -150%)'; // Eindpositie (boven)
        }, 50);

        // Reset na de animatie
        setTimeout(() => {
            feedbackEl.style.opacity = '0';
            feedbackEl.style.transform = 'translate(-50%, -50%)'; // Terug naar startpositie
            playerCard.classList.remove('time-gain-flash');
            playerCard.classList.remove('time-loss-flash');
        }, 2000); 

    }
    // *** EINDE OPTIMALISATIE ***


    function flashPlayerCard(playerIndex, duration = 2000) {
        const playerCard = document.querySelector(`.player-card[data-player-index="${playerIndex}"]`);
        if (!playerCard) return;

        playerCard.classList.add('time-gain-flash');

        setTimeout(() => {
            playerCard.classList.remove('time-gain-flash');
            renderPlayers();
        }, duration);
    }


    let players = [];

    let sortedPlayersR4 = [];

    let activePuzzle = [];

    let activeOpenDeur = null;

    let isGameOver = false;


    let finalists = [];

    let activeFinalistIndex = 0;

    let currentFinaleQuestion = null;

    let foundFinaleKeywords = [];

    let finaleQuestionIndex = 0;


    const MEMORY_QUESTIONS_PER_LIST = 6;

    const FINALE_QUESTIONS = 1000;


    const MAX_R1_QUESTIONS = 8; // AANGEPAST naar 8 vragen


    // ==========================================================
    // SPEL LOGICA
    // ==========================================================


    let activePlayerIndex = 0;

    let currentRound = 0;

    let currentQuestionIndex = 0;

    let timerInterval = null;

    let isTimerRunning = false;

    let timerPlayerIndex = null;


    let currentQuestionAttempts = [];

    let nextPlayerAfterFail = -1;


    let activeRound1Questions = [];


    let activeRound2Puzzles = [];

    let currentPuzzleSet = null;

    let currentPuzzleSetIndex = 0;
    let currentR2SetCount = 0;


    let activeOpenDeurQuestions = [];
    let currentOpenDeurIndex = 0;
    let currentR3QuestionCount = 0;


    let activeRound4Questions = [];

    let currentMemoryQuestion = null;
    let currentR4PlayerCount = 0;


    let R4_FULL_SHUFFLED_POOL = [];

    let R4_POOL_INDEX = 0;


    let activeFinaleQuestions = [];

    let currentFinaleQuestionIndex = 0;

    // NIEUW: Houd bij welke spelers op de huidige set/vraag hebben gepast/gefaald
    let currentSetAttempts = [];


    const setupScreen = document.getElementById('setup-screen');

    const playerNameInputs = document.getElementById('player-name-inputs');

    const numPlayersInput = document.getElementById('num-players');

    const themeSelect = document.getElementById('theme-select');

    const playerContainer = document.getElementById('player-container');

    const gameBoard = document.getElementById('game-board');


    const roundTitle = document.getElementById('round-title');

    const questionText = document.getElementById('question-text');

    const questionCounter = document.getElementById('question-counter');

    const questionIdElement = document.getElementById('question-id');

    const puzzleIdsElement = document.getElementById('puzzle-ids');

    const inputAnswer = document.getElementById('answer-input');


    const btnCheckAnswer = document.getElementById('check-answer');


    // De testknoppen zijn uit de HTML verwijderd, maar hun verwijzingen in JS worden hier opgeruimd:
    // const btnTestRound2 = document.getElementById('test-ronde-2');
    // const btnTestRound3 = document.getElementById('test-ronde-3');
    // const btnTestRound4 = document.getElementById('test-ronde-4');

    const btnStartRound1 = document.getElementById('start-round-1');

    const btnStartRound2 = document.getElementById('start-round-2');

    const btnStartRound3 = document.getElementById('start-round-3');

    const btnStartRound4 = document.getElementById('start-round-4');

    const btnStartFinale = document.getElementById('start-finale');

    // const btnPas = document.getElementById('btn-pas'); // VERWIJDERD


    const opendeurDisplayArea = document.getElementById('opendeur-display-area');

    const opendeurSubject = document.getElementById('opendeur-subject');


    const geheugenDisplayArea = document.getElementById('geheugen-display-area');

    const geheugenBoard = document.getElementById('geheugen-board');


    const btnNextPuzzle = document.getElementById('next-puzzle');

    const btnNextOpenDeur = document.getElementById('next-opendeur');

    const btnNextGeheugenSpeler = document.getElementById('next-geheugen-speler');


    const btnShowPuzzleAnswers = document.getElementById('show-puzzle-answers');

    const btnShowOpenDeurAnswers = document.getElementById('show-opendeur-answers');

    const btnShowGeheugenAnswers = document.getElementById('show-geheugen-answers');

    const btnFinaleShow = document.getElementById('btn-finale-show');

    const btnFinaleNext = document.getElementById('btn-finale-next');


    const btnWrongAnswer = document.getElementById('wrong-answer');

    const btnAdd10 = document.getElementById('add-seconds-10');

    const btnAdd20 = document.getElementById('add-seconds-20');


    function getNextStartingPlayerIndex(round) {

        // Logica om de speler met de laagste score te bepalen als de starter.

        let eligiblePlayers = players.filter(p => p.seconds > 0);

        if (eligiblePlayers.length === 0) {
            // Als niemand seconden heeft, start de speler met de laagste (0)
            const lowestScorePlayer = players.sort((a, b) => a.seconds - b.seconds)[0];
            return lowestScorePlayer ? lowestScorePlayer.originalIndex : 0;
        }

        eligiblePlayers.sort((a, b) => a.seconds - b.seconds);

        return eligiblePlayers[0].originalIndex;
    }


    // Verbeterde Functie om de volgende speler te vinden die NOG KAN spelen (Ronde 2, 3, 4)
    function getNextPlayerForSet(currentIndex, attemptsArray) {
        const playerCount = players.length;
        // Gebruik de array-index, niet de originalIndex, om te cyclen
        let startIndex = players.findIndex(p => p.originalIndex === currentIndex);

        for (let i = 1; i <= playerCount; i++) { // Loop door alle spelers, beginnend bij de speler na de huidige
            const nextPlayerArrayIndex = (startIndex + i) % playerCount;
            const nextPlayerOriginalIndex = players[nextPlayerArrayIndex].originalIndex;
            const nextPlayer = players[nextPlayerArrayIndex];

            // 1. Speler moet seconden hebben om mee te kunnen doen
            // 2. Speler mag nog niet geprobeerd hebben op deze set
            if (nextPlayer.seconds > 0 && !attemptsArray.includes(nextPlayerOriginalIndex)) {
                return nextPlayerOriginalIndex;
            }
        }
        
        // Als we hier komen, betekent het dat iedereen die seconden heeft geprobeerd heeft of gepast heeft.
        return -1; // Iedereen heeft geprobeerd
    }


    function formatAndDisplayIDs(idArray) {

        const idString = idArray.join(',');

        puzzleIdsElement.innerHTML = `

            ID's voor controle:

            <span id="ids-to-copy">${idString}</span>

            <button class="copy-ids-btn" onclick="copyToClipboard('${idString}')" title="Kopieer ID's">✨</button>

        `;

        puzzleIdsElement.style.display = 'flex';

    }


    function copyToClipboard(text) {

        navigator.clipboard.writeText(text).then(() => {

            const button = puzzleIdsElement.querySelector('.copy-ids-btn');

            const originalTitle = button.title;

            button.title = "Gekopieerd!";

            setTimeout(() => {

                button.title = originalTitle;

            }, 1000);

        }).catch(err => {

            console.error('Kopiëren mislukt:', err);

            alert('Kopiëren mislukt. Probeer handmatig te kopiëren.');

        });

    }

    window.copyToClipboard = copyToClipboard;


    function showFeedback(isCorrect) {
        const className = isCorrect ? 'correct-feedback' : 'wrong-feedback';

        inputAnswer.classList.remove('correct-feedback', 'wrong-feedback');
        inputAnswer.classList.add(className);

        const flashDuration = isCorrect ? 2000 : 1500;

        inputAnswer.focus();

        setTimeout(() => {
            inputAnswer.classList.remove(className);
            inputAnswer.focus();
        }, flashDuration);
    }


    function updatePlayerInputs() {

        let num = parseInt(numPlayersInput.value);

        num = Math.max(1, Math.min(6, num));

        numPlayersInput.value = num;


        playerNameInputs.innerHTML = "";

        for (let i = 0; i < num; i++) {

            const row = document.createElement('div');

            row.className = 'setup-input-row';

            const defaultValue = (i < 4) ? `Speler ${i + 1}` : '';

            row.innerHTML = `

                <label>Speler ${i + 1}:</label>

                <input type="text" id="player-name-${i}" placeholder="Naam speler ${i + 1}" value="${defaultValue}">

            `;

            playerNameInputs.appendChild(row);

        }

    }


    function populateThemeSelector() {

    }


    function initializeGame(startRound = 1) {

        // FIX: Controleer of de ThemeManager klaar is
        if (!window.ThemeManager) {
            console.error("ThemeManager is niet gedefinieerd. Zorg ervoor dat quizdata_loader.js correct is geladen.");
            // Toon een foutmelding op de pagina als de setup-screen verborgen zou zijn.
            setupScreen.style.display = 'block';
            setupScreen.classList.add('visible');
            return;
        }

        quizData = window.ThemeManager.getActiveTheme('STANDAARD');


        players = [];

        const numPlayers = parseInt(numPlayersInput.value);

        let allNamesValid = true;

        const inputElements = playerNameInputs.querySelectorAll('input[type="text"]');


        for (let i = 0; i < numPlayers; i++) {

            const inputElement = inputElements[i];

            const name = inputElement ? inputElement.value.trim() : '';


            if (i < 2 && !name) {

                if (inputElement) inputElement.style.borderColor = 'var(--wrong-color)';

                allNamesValid = false;

            } else if (name) {

                if (inputElement) inputElement.style.borderColor = 'var(--input-border-color)';

                players.push({

                    name: name,

                    seconds: 60,

                    originalIndex: i

                });

            }

        }


        if (allNamesValid && players.length >= 2) {

            // FIX: Reset tellers en set attempts bij het initialiseren van een nieuwe game/testronde
            currentR2SetCount = 0;
            currentR3QuestionCount = 0;
            currentR4PlayerCount = 0;

            currentPuzzleSetIndex = 0;
            currentOpenDeurIndex = 0;
            currentMemoryList = 0;

            currentSetAttempts = []; // NIEUW: Reset attempts

            activePlayerIndex = players[0].originalIndex;

            timerPlayerIndex = activePlayerIndex;


            // Herinitialiseer keywords om de 'found' status te resetten
            if (quizData.ronde3_openDeur) {
                quizData.ronde3_openDeur = quizData.ronde3_openDeur.map(q => ({
                    ...q,
                    keywords: q.keywords.map(word => ({ word: (typeof word === 'string' ? word : word.word), found: false }))
                }));
            }
            if (quizData.ronde5_finale) {
                quizData.ronde5_finale = quizData.ronde5_finale.map(q => ({
                    ...q,
                    keywords: q.keywords.map(word => ({ word: (typeof word === 'string' ? word : word.word), found: false }))
                }));
            }


            setupScreen.style.display = 'none';

            playerContainer.style.display = 'grid';

            gameBoard.style.display = 'block';


            renderPlayers();


            // btnPas.style.display = 'inline-block'; // VERWIJDERD


            if (startRound === 2) {

                setupRound2();

            } else if (startRound === 3) {

                setupRound3();

            } else if (startRound === 4) {

                setupRound4();

            } else {

                startGameR1();

            }


        } else if (!allNamesValid || players.length < 2) {

            alert("Je hebt minimaal 2 spelers nodig en hun namen mogen niet leeg zijn.");

            const invalidInput = Array.from(inputElements).find(input => input.style.borderColor === 'var(--wrong-color)');

            if (invalidInput) invalidInput.focus();

            return false;

        }

        return true;

    }


    window.addEventListener('load', () => {

        populateThemeSelector();

        updatePlayerInputs();

        setupScreen.classList.add('visible');
    });

    document.addEventListener('keydown', (event) => {
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
            return;
        }

        if (event.key.toLowerCase() === 'x') {

            if (currentRound >= 2 && currentRound <= 5) {
                if (activePlayerIndex !== null && players.find(p => p.originalIndex === activePlayerIndex)) {
                    toggleTimer(activePlayerIndex);
                    event.preventDefault();
                }
            }
        }
    });


    function renderPlayers() {

        playerContainer.innerHTML = "";


        const playersToShow = (currentRound === 5) ? finalists.map(f => f.player) : players;


        playersToShow.forEach((player, index) => {

            const playerObj = (currentRound === 5) ? finalists[index].player : player;

            const originalIndex = playerObj.originalIndex !== undefined ? playerObj.originalIndex : index;

            // Verwijderde: hasStarted logica

            const isDisabled = false; // Verwijderde: hasStarted logica


            playerContainer.style.gridTemplateColumns = `repeat(auto-fit, minmax(120px, 1fr))`;


            const card = document.createElement('div');

            card.className = 'player-card';

            card.dataset.playerIndex = originalIndex;


            if (originalIndex === activePlayerIndex) {
                card.classList.add('active');
                if (currentRound === 5) {
                    card.classList.add('final-player');
                }
            } else if (currentRound === 5) {
                card.classList.add('opponent-player');
            }

            if (isDisabled) {
                card.classList.add('disabled');
            }

            if (playerCardIsFlashing(originalIndex)) {
                card.classList.add('time-gain-flash');
            }


            let timerButtonSymbol = '►';
            if (isTimerRunning && timerPlayerIndex === originalIndex) {
                timerButtonSymbol = '❚❚';
            }

            let timerButtonClass = 'player-timer-btn';
            if (isTimerRunning && timerPlayerIndex === originalIndex) {
                timerButtonClass += ' running';
            }


            let checkmark = ''; // Verwijderd: checkmark logica


            card.innerHTML = `

                <div class="player-name">${player.name}</div>

                <div class="player-seconds">${player.seconds}</div>

                <button class="${timerButtonClass}" data-player-index="${originalIndex}" style="position: absolute; top: 5px; right: 5px;">${timerButtonSymbol}</button>

                ${checkmark ? `<span class="puzzle-starter-check" style="position: absolute; top: 8px; left: 8px;">${checkmark}</span>` : ''}

                <div class="bonus-feedback"></div>

            `;


            card.style.position = 'relative';

            playerContainer.appendChild(card);

        });

    }

    function playerCardIsFlashing(playerIndex) {
        const playerCard = document.querySelector(`.player-card[data-player-index="${playerIndex}"]`);
        return playerCard && playerCard.classList.contains('time-gain-flash');
    }


    function startTimer(playerIndex) {

        document.body.classList.remove('timer-stopped');

        let player = players.find(p => p.originalIndex === playerIndex);

        if (!player || player.seconds <= 0) {

            return;

        }


        if (isTimerRunning) return;


        isTimerRunning = true;

        timerPlayerIndex = playerIndex;


        if (currentRound >= 2 && currentRound <= 5) {
            gameBoard.classList.add('clues-visible');
            inputAnswer.style.display = 'inline-block';
            btnCheckAnswer.style.display = 'inline-block';
        }


        if (currentRound >= 1 && currentRound <= 5) {

            inputAnswer.disabled = false;

        }


        timerInterval = setInterval(() => {

            let player = players.find(p => p.originalIndex === timerPlayerIndex);

            if (!player) return;


            player.seconds--;

            if (player.seconds <= 0) {

                player.seconds = 0;

                stopTimer();

                if (currentRound === 5) {
                    const loserPlayer = players.find(p => p.originalIndex === timerPlayerIndex);
                    const winnerPlayer = finalists.map(f => f.player).find(p => p.originalIndex !== loserPlayer.originalIndex);

                    if (winnerPlayer) {
                        showFinaleWinner(winnerPlayer);
                        return;
                    }
                }

                if (currentRound >= 2 && currentRound <= 4) {
                    // Pas de beurt automatisch door als de klok op 0 loopt
                    pasDeBeurt();
                }


            }

            renderPlayers();

        }, 1000);


        renderPlayers();

    }


    function stopTimer() {

        document.body.classList.add('timer-stopped');

        clearInterval(timerInterval);

        timerInterval = null;

        isTimerRunning = false;

        // timerPlayerIndex wordt NIET op null gezet hier, zodat we weten wie de klok had bij 'Pas de beurt'


        gameBoard.classList.remove('clues-visible');

        if (currentRound === 4 && !geheugenBoard.classList.contains('answers-shown')) {

        }


        if (currentRound >= 2 && currentRound <= 5) {

            inputAnswer.disabled = true;

        }


        renderPlayers();

    }

    // Verwijderde: setStarterCheck functie


    function pasDeBeurt() {
        // TimerPlayerIndex wordt gebruikt om te onthouden wie de klok had
        const previousPlayerIndex = timerPlayerIndex;

        stopTimer();


        if (currentRound === 1) {
            // Logica voor ronde 1 (gewoon doorschuiven)
            let currentPlayerArrayIndex = players.findIndex(p => p.originalIndex === activePlayerIndex);
            let nextPlayerArrayIndex = (currentPlayerArrayIndex + 1) % players.length;
            activePlayerIndex = players[nextPlayerArrayIndex].originalIndex;

            // Start de klok niet direct in R1, de volgende speler klikt
            renderPlayers();

            return;
        }

        if (currentRound >= 2 && currentRound <= 4) {

            // NIEUWE LOGICA: Voeg de speler die net de beurt had toe aan de attempts array
            if (previousPlayerIndex !== null && !currentSetAttempts.includes(previousPlayerIndex)) {
                currentSetAttempts.push(previousPlayerIndex);
            }

            const nextPlayer = getNextPlayerForSet(activePlayerIndex, currentSetAttempts);

            if (nextPlayer !== -1) {
                // Geef de beurt door aan de volgende speler die nog niet geprobeerd heeft EN nog seconden heeft
                activePlayerIndex = nextPlayer;
                renderPlayers(); // <--- GEEN TIMEOUT MEER, DUS DIRECTE OVERGANG
                // Speler start de klok door te klikken
            } else {
                // Iedereen met seconden heeft geprobeerd/gepast, dus de set/vraag is afgesloten
                if (currentRound === 2) {
                    showPuzzleAnswers(); // Toont antwoorden en forceert Next
                } else if (currentRound === 3) {
                    showOpenDeurAnswers(); // Toont antwoorden en forceert Next
                } else if (currentRound === 4) {
                    showMemoryAnswers(); // Toont antwoorden en forceert Next
                }
            }
            return;
        }

        if (currentRound === 5) {
            // Logica voor Finale: Wissel van speler
            const nextFinalistIndex = (activeFinalistIndex + 1) % finalists.length;
            activeFinalistIndex = nextFinalistIndex;
            activePlayerIndex = finalists[activeFinalistIndex].player.originalIndex;

            // Laat de volgende speler de klok starten door op hun kaart te klikken
            renderPlayers();
            return;
        }

        renderPlayers(); // Zorg altijd dat de UI up-to-date is
    }


    function toggleTimer(clickedIndex) {

        if (isGameOver) return;

        let player = players.find(p => p.originalIndex === clickedIndex);
        if (!player || player.seconds <= 0) {
            if (currentRound >= 2) {
                if (timerPlayerIndex !== clickedIndex) {
                    alert("Deze speler heeft geen seconden meer over en kan de klok niet starten.");
                }
            }
            return;
        }

        // In R2/R3/R4, als de set al bezig is, mag alleen een speler die NOG NIET heeft geprobeerd de klok starten.
        if (currentRound >= 2 && currentRound <= 4 && currentSetAttempts.length > 0) {
            if (currentSetAttempts.includes(clickedIndex)) {
                alert("Deze speler heeft al een beurt gepast/gefaald op deze set. Wacht op de volgende beurt.");
                return;
            }
        }


        activePlayerIndex = clickedIndex;

        if (currentRound === 5) {
            activeFinalistIndex = finalists.findIndex(f => f.player.originalIndex === clickedIndex);
        }

        if (!isTimerRunning) {
            // Verwijderde: setStarterCheck(clickedIndex);
            startTimer(clickedIndex);
        } else if (timerPlayerIndex === clickedIndex) {
            stopTimer();

            if (currentRound >= 2) {
                pasDeBeurt();
            }


        } else {
            stopTimer();
            // Verwijderde: setStarterCheck(clickedIndex);
            startTimer(clickedIndex);
        }
    }


    function updateSeconds(playerIndex, amount) {

        if (isGameOver) return;

        // Verwijderde: stop de timer bij verlies van seconden in R2-R5. De speler mag blijven spelen.


        let player = players.find(p => p.originalIndex === playerIndex);

        if (!player) return;


        const newSeconds = player.seconds + amount;

        if (currentRound === 5 && newSeconds <= 0) {
            const loserPlayer = player;
            const winnerPlayer = finalists.map(f => f.player).find(p => p.originalIndex !== loserPlayer.originalIndex);

            if (winnerPlayer && winnerPlayer.seconds > 0) {
                player.seconds = 0;
                renderPlayers();
                showFinaleWinner(winnerPlayer);
                return;
            }
        }

        player.seconds += amount;

        if (player.seconds < 0) {

            player.seconds = 0;

        }

        // Alleen positieve flash via deze directe functie
        if (amount > 0 && currentRound >= 1 && currentRound <= 4) {
            // flashCard wordt nu aangeroepen via showBonusFeedback om dubbele aanroep te voorkomen
        }


        renderPlayers();

    }


    function shuffleArray(array) {

        for (let i = array.length - 1; i > 0; i--) {

            const j = Math.floor(Math.random() * (i + 1));

            [array[i], array[j]] = [array[j], array[i]];

        }

        return array;

    }


    function hideAllGameAreas() {

        const controlsToHide = [
            questionCounter,
            document.getElementById('puzzle-display-area'),
            document.getElementById('opendeur-display-area'),
            document.getElementById('geheugen-display-area'),
            document.getElementById('finale-display-area'),
            // document.getElementById('test-ronde-2'), // VERWIJDERD
            // document.getElementById('test-ronde-3'), // VERWIJDERD
            // document.getElementById('test-ronde-4'), // VERWIJDERD
            btnStartRound1,
            btnStartRound2,
            document.getElementById('start-round-3'),
            document.getElementById('start-round-4'),
            document.getElementById('start-finale'),
            document.getElementById('next-puzzle'),
            document.getElementById('next-opendeur'),
            document.getElementById('next-geheugen-speler'),
            document.getElementById('show-puzzle-answers'),
            document.getElementById('show-opendeur-answers'),
            document.getElementById('show-geheugen-answers'),
            document.getElementById('btn-finale-show'),
            document.getElementById('btn-finale-next')
        ];

        controlsToHide.forEach(el => {
            // Controleer of het element bestaat voordat style.display wordt ingesteld
            if (el) el.style.display = 'none';
        });


        questionText.style.display = 'none';

        questionIdElement.style.display = 'none';

        puzzleIdsElement.style.display = 'none';


        // btnPas.style.display = 'inline-block'; // VERWIJDERD


        inputAnswer.style.display = 'none';
        btnCheckAnswer.style.display = 'none';

    }


    function startGameR1() {

        currentRound = 1;

        currentQuestionIndex = 0;

        roundTitle.textContent = "Ronde 1: Algemene Kennis"; // VERBETERING: Ronde naam tonen


        const fullPool = [...quizData.ronde1_pool];

        shuffleArray(fullPool);


        activeRound1Questions = fullPool.slice(0, Math.min(fullPool.length, MAX_R1_QUESTIONS));


        hideAllGameAreas();

        questionText.style.display = 'block';
        questionCounter.style.display = 'block';
        questionIdElement.style.display = 'block';


        inputAnswer.style.display = 'inline-block';
        btnCheckAnswer.style.display = 'inline-block';
        btnCheckAnswer.textContent = "Controleer Antwoord";


        inputAnswer.disabled = false;


        stopTimer();

        displayQuestion();


        const allR1IDs = activeRound1Questions.map(q => q.id);

        formatAndDisplayIDs(allR1IDs);

    }


    function displayQuestion() {

        const roundData = activeRound1Questions;

        const totalQuestions = roundData.length;


        if (currentQuestionIndex < totalQuestions) {

            currentQuestionAttempts = [];


            const currentQuestion = roundData[currentQuestionIndex];

            const questionNumber = currentQuestionIndex + 1;


            // FIX: Verwijder de felle kleur en maak de tekst minder opvallend
            questionText.textContent = currentQuestion.q;
            questionIdElement.textContent = `Vraag-ID: #${currentQuestion.id}`;


            // AANGEPAST: Toon de nieuwe beloning voor Ronde 1 (+20 SECONDEN)
            questionCounter.innerHTML = `Vraag ${questionNumber} / ${totalQuestions} (Beloning: <strong>+${R1_BONUS_SECONDS} SECONDEN</strong> per juist antwoord)`;


            roundTitle.textContent = "Ronde 1: Algemene Kennis"; // VERBETERING: Ronde naam tonen

            inputAnswer.value = "";

            inputAnswer.focus();


            timerPlayerIndex = activePlayerIndex;

            renderPlayers();

        } else {

            hideAllGameAreas();

            questionText.style.display = 'block';

            questionText.textContent = "Einde van Ronde 1.";


            btnStartRound2.style.display = 'inline-block';

            puzzleIdsElement.style.display = 'none';

        }

    }

    // *** NIEUWE FUNCTIE: Toon het juiste antwoord en ga door naar de volgende vraag (Ronde 1) ***
    function displayCorrectAnswerAndNextQuestion(currentQuestion) {
        // 1. Toon het juiste antwoord
        questionText.textContent = `Niemand wist het. Het antwoord was: ${currentQuestion.a}`;
        inputAnswer.style.display = 'none'; // Verberg de input
        btnCheckAnswer.style.display = 'none'; // Verberg de knop
        // btnPas.style.display = 'none'; // VERWIJDERD

        const isLastQuestion = (currentQuestionIndex + 1) >= activeRound1Questions.length;
        const timeoutDuration = isLastQuestion ? 100 : 3000; // Sneller doorgaan als het de laatste is

        // 2. Wacht 3 seconden (lang genoeg om het antwoord te zien)
        setTimeout(() => {
            // Ga naar de volgende vraag
            currentQuestionIndex++;

            // Vind de speler die nu aan de beurt is (e.g. de speler na degene die net de laatste poging deed)
            if (currentQuestionIndex < activeRound1Questions.length) {
                const currentPlayerArrayIndex = players.findIndex(p => p.originalIndex === activePlayerIndex);
                const nextPlayerArrayIndex = (currentPlayerArrayIndex + 1) % players.length;
                activePlayerIndex = players[nextPlayerArrayIndex].originalIndex;
            }

            displayQuestion(); // Toont de volgende vraag of einde ronde

            // Zorg dat de knoppen terugkomen voor de nieuwe vraag/beurt
            if (currentQuestionIndex < activeRound1Questions.length) {
                inputAnswer.style.display = 'inline-block';
                btnCheckAnswer.style.display = 'inline-block';
                // btnPas.style.display = 'inline-block'; // VERWIJDERD
            }

        }, timeoutDuration); // Wacht 3 seconden

    }
    // *** EINDE NIEUWE FUNCTIE ***


    function checkAnswer() {

        const isGMCheck = inputAnswer.disabled && !isTimerRunning && currentRound >= 2;

        if (currentRound !== 1 && currentRound !== 5 && !isTimerRunning && !isGMCheck) {
            return;

        }


        if (isGMCheck) {

            const userAnswer = inputAnswer.value.toLowerCase().trim();
            let isCorrect = false;

            if (currentRound === 2) {
                isCorrect = currentPuzzleSet.some(p => stringSimilarity(p.answer, userAnswer) >= SIMILARITY_THRESHOLD);

            } else if (currentRound === 3) {
                isCorrect = activeOpenDeur.keywords.some(k => stringSimilarity(k.word, userAnswer) >= SIMILARITY_THRESHOLD);

            } else if (currentRound === 4) {
                isCorrect = activeRound4Questions.some(q => stringSimilarity(q.a, userAnswer) >= SIMILARITY_THRESHOLD);

            } else if (currentRound === 5) {
                isCorrect = currentFinaleQuestion.keywords.some(k => stringSimilarity(k.word, userAnswer) >= SIMILARITY_THRESHOLD);
            }

            showFeedback(isCorrect);

            return;
        }


        if (currentRound === 1) {

            checkRound1Answer();

        } else if (currentRound === 2) {

            checkRound2Answer();

        } else if (currentRound === 3) {

            checkRound3Answer();

        } else if (currentRound === 4) {

            checkRound4Answer();

        } else if (currentRound === 5) {

            checkFinaleAnswer();

        }

    }


    function checkRound1Answer() {

        const roundData = activeRound1Questions;

        if (currentQuestionIndex >= roundData.length) return;


        const currentQuestion = roundData[currentQuestionIndex];

        const userAnswer = inputAnswer.value.toLowerCase().trim();

        const correctAnswer = currentQuestion.a.toLowerCase().trim();


        const similarityScore = stringSimilarity(correctAnswer, userAnswer);
        const isCorrect = (similarityScore >= SIMILARITY_THRESHOLD);


        stopTimer();
        inputAnswer.value = "";

        if (isCorrect) {


            showFeedback(true);


            // AANGEPAST: Gebruik R1_BONUS_SECONDS
            let secondsToAdd = R1_BONUS_SECONDS;

            // *** ZORG DAT DE ANIMATIE HIER WORDT GETRIGGERD ***
            showBonusFeedback(activePlayerIndex, secondsToAdd);

            updateSeconds(activePlayerIndex, secondsToAdd); // <-- Seconden bijgewerkt


            setTimeout(() => {

                currentQuestionIndex++;

                displayQuestion();

            }, 2000);


        } else {


            showFeedback(false);


            if (!currentQuestionAttempts.includes(activePlayerIndex)) {

                currentQuestionAttempts.push(activePlayerIndex);

            }


            const allPlayersTried = currentQuestionAttempts.length === players.length;


            // setTimeout(() => { // <--- VERWIJDERD om de overgang direct te maken

                let nextPlayerFound = false;
                let nextPlayerIndex = -1;
                let currentPlayerArrayIndex = players.findIndex(p => p.originalIndex === activePlayerIndex);
                
                // Check door alle spelers heen, startend na de huidige speler
                for (let i = 1; i <= players.length; i++) {
                    currentPlayerArrayIndex = (currentPlayerArrayIndex + 1) % players.length;
                    const candidatePlayer = players[currentPlayerArrayIndex];
                    
                    // 1. Speler mag nog niet geprobeerd hebben
                    // 2. Speler moet meer dan 0 seconden hebben om nog mee te doen
                    if (!currentQuestionAttempts.includes(candidatePlayer.originalIndex) && candidatePlayer.seconds > 0) {
                        nextPlayerIndex = candidatePlayer.originalIndex;
                        nextPlayerFound = true;
                        break; // Volgende speler gevonden
                    }
                }


                if (nextPlayerFound) {
                    // Deel de beurt uit
                    const nextPlayerAfterFail = nextPlayerIndex;

                    questionText.textContent = `${players.find(p => p.originalIndex === nextPlayerIndex).name} is aan de beurt.`;

                    setTimeout(() => {

                        questionText.textContent = currentQuestion.q;

                        activePlayerIndex = nextPlayerIndex;

                        renderPlayers();

                        inputAnswer.focus();

                    }, 1500);

                } else {
                    // Iedereen met seconden heeft de vraag geprobeerd. Toon antwoord en ga door.
                    displayCorrectAnswerAndNextQuestion(currentQuestion);
                }

            // }, 1500); // <--- VERWIJDERD om de overgang direct te maken

        }

    }


    function setupRound2() {

        currentRound = 2;

        currentPuzzleSetIndex = 0;
        currentR2SetCount = 0; // FIX: Reset teller
        currentSetAttempts = []; // NIEUW: Reset attempts

        activePlayerIndex = getNextStartingPlayerIndex(2);


        roundTitle.textContent = `Ronde 2: De Puzzel (Beloning: +${R2_R3_R4_BONUS_SECONDS} sec)`; // VERBETERING: Ronde naam tonen


        const fullPool = [...quizData.ronde2_answer_pool];

        shuffleArray(fullPool);


        activeRound2Puzzles = [];


        const totalSetsNeeded = players.length;
        const requiredItems = totalSetsNeeded * 3;


        if (fullPool.length < requiredItems) {

            alert(`Niet genoeg puzzel items beschikbaar in de data (${fullPool.length}). U heeft ${requiredItems} puzzels nodig. Door naar de volgende ronde.`);

            btnStartRound3.style.display = 'inline-block';

            return;

        }

        // FIX: Zorg ervoor dat we exact de benodigde puzzels selecteren om een set per speler te garanderen
        const selectedPuzzles = fullPool.slice(0, requiredItems);


        for (let i = 0; i < totalSetsNeeded; i++) {


            const setOfThree = selectedPuzzles.slice(i * 3, (i + 1) * 3).map((p, j) => ({

                ...p,

                found: false,

                color: `color-${(j % 3) + 1}`,

                clues: p.clues.map(c => ({ text: c, color: `color-${(j % 3) + 1}` }))

            }));

            activeRound2Puzzles.push(setOfThree);

        }


        btnStartRound3.style.display = 'none';


        hideAllGameAreas();

        document.getElementById('puzzle-display-area').style.display = 'flex';
        questionText.style.display = 'block';
        questionCounter.style.display = 'block'; // VERBETERING: Toon teller


        btnNextPuzzle.style.display = 'none';
        btnShowPuzzleAnswers.style.display = 'inline-block';


        loadNewPuzzle();

    }


    function loadNewPuzzle() {

        const nextStarterIndex = getNextStartingPlayerIndex(2);

        // NIEUWE LOGICA: Controleer of alle sets gespeeld zijn
        if (currentR2SetCount >= players.length) {
            hideAllGameAreas();
            questionText.style.display = 'block';
            questionText.textContent = "Einde van Ronde 2.";
            btnStartRound3.style.display = 'inline-block';
            return;
        }

        // FIX: currentPuzzleSetIndex moet altijd gelijk zijn aan currentR2SetCount om de juiste set te laden
        currentPuzzleSetIndex = currentR2SetCount;


        if (currentPuzzleSetIndex >= activeRound2Puzzles.length) {
            // Als er geen volgende set is, forceren we het einde.
            currentR2SetCount = players.length;
            hideAllGameAreas();
            questionText.textContent = "Einde van Ronde 2.";
            btnStartRound3.style.display = 'inline-block';
            return;
        }


        activePlayerIndex = nextStarterIndex;
        currentSetAttempts = []; // NIEUW: Reset attempts voor de nieuwe set


        roundTitle.textContent = `Ronde 2: De Puzzel (Beloning: +${R2_R3_R4_BONUS_SECONDS} sec)`; // VERBETERING: Ronde naam tonen

        currentPuzzleSet = activeRound2Puzzles[currentPuzzleSetIndex];


        const solvedCount = currentPuzzleSet.filter(p => p.found).length;


        // AANGEPAST: Toon de nieuwe beloning voor Ronde 2 (+40 SECONDEN)
        questionCounter.innerHTML = `Puzzel ${currentR2SetCount + 1} / ${players.length} (Beloning: <strong>+${R2_R3_R4_BONUS_SECONDS} SECONDEN</strong> per juist antwoord)`;


        let allClues = [];
        let currentPuzzleIDs = [];


        currentPuzzleSet.forEach(p => {

            currentPuzzleIDs.push(p.id);

            p.clues.forEach(clue => {

                allClues.push({

                    text: clue.text,

                    answer: p.answer.toLowerCase().trim(),

                    color: clue.color,

                    isFound: p.found

                });

            });

        });


        shuffleArray(allClues);


        questionText.textContent = `Puzzel ${currentR2SetCount + 1}`;


        const answersContainer = document.getElementById('puzzle-answers-container');

        const cluesContainer = document.getElementById('puzzle-clues-container');

        answersContainer.innerHTML = '';

        cluesContainer.innerHTML = '';


        btnStartRound3.style.display = 'none';


        currentPuzzleSet.forEach(p => {

            const el = document.createElement('div');


            el.className = `puzzle-answer ${p.found ? 'found ' + p.color : ''}`;

            el.textContent = p.found ? p.answer : '???';

            el.dataset.answer = p.answer.toLowerCase().trim();

            answersContainer.appendChild(el);

        });


        for (let i = 0; i < 12; i++) {

            const clueObj = allClues[i];

            const el = document.createElement('div');


            const set = currentPuzzleSet.find(s => s.answer.toLowerCase().trim() === clueObj.answer);

            const isFoundClass = (set && set.found) ? 'found ' + clueObj.color : '';


            el.className = `puzzle-clue ${isFoundClass}`;
            el.textContent = clueObj.text;
            el.dataset.answer = clueObj.answer;
            cluesContainer.appendChild(el);
        }


        const isCompleted = solvedCount === 3;

        btnNextPuzzle.style.display = 'none';
        btnShowPuzzleAnswers.style.display = isCompleted ? 'none' : 'inline-block';
        btnCheckAnswer.style.display = isCompleted ? 'none' : 'inline-block';
        inputAnswer.style.display = isCompleted ? 'none' : 'inline-block';
        // btnPas.style.display = 'inline-block'; // VERWIJDERD

        if (isCompleted) {
            // Als voltooid, toon Volgende knop
            btnNextPuzzle.style.display = 'inline-block';
        }


        inputAnswer.disabled = true;


        stopTimer();

        renderPlayers();

        inputAnswer.value = '';

        inputAnswer.focus();

    }


    function updatePuzzleDisplay() {

        if (!currentPuzzleSet) return;

        roundTitle.textContent = `Ronde 2: De Puzzel (Beloning: +${R2_R3_R4_BONUS_SECONDS} sec)`; // VERBETERING: Ronde naam tonen

        const solvedCount = currentPuzzleSet.filter(p => p.found).length;


        const displaySetCount = currentR2SetCount + 1;
        // AANGEPAAST: Toon de nieuwe beloning voor Ronde 2 (+40 SECONDEN)
        questionCounter.innerHTML = `Puzzel ${displaySetCount} / ${players.length} (Beloning: <strong>+${R2_R3_R4_BONUS_SECONDS} SECONDEN</strong> per juist antwoord)`;


        const answersContainer = document.getElementById('puzzle-answers-container');
        currentPuzzleSet.forEach((p, index) => {
            if (p.found) {
                const el = answersContainer.children[index];
                el.className = `puzzle-answer found ${p.color}`;
                el.textContent = p.answer;

                const cluesContainer = document.getElementById('puzzle-clues-container');
                Array.from(cluesContainer.children).forEach(clueEl => {
                    if (clueEl.dataset.answer === p.answer.toLowerCase().trim()) {
                        clueEl.classList.add('found');
                        clueEl.classList.add(p.color);
                    }
                });
            }
        });


        if (solvedCount === 3) {


            stopTimer();

            questionText.textContent = "Alle 3 antwoorden zijn gevonden! Druk op 'Volgende Puzzel'.";


            btnShowPuzzleAnswers.style.display = 'none';
            btnCheckAnswer.style.display = 'none';
            inputAnswer.style.display = 'none';
            // btnPas.style.display = 'none'; // VERWIJDERD
            currentSetAttempts = [...players.map(p => p.originalIndex)]; // Markeer iedereen als 'gepasseerd' omdat de set af is

            // Toon altijd de Next knop; de controle of de ronde eindigt gebeurt in nextPuzzleSet
            btnNextPuzzle.style.display = 'inline-block';
            activePlayerIndex = getNextStartingPlayerIndex(2);
            renderPlayers();
        }

    }


    function checkRound2Answer() {


        const userAnswer = inputAnswer.value.toLowerCase().trim();


        const foundItem = currentPuzzleSet.find(p =>
            !p.found && stringSimilarity(p.answer, userAnswer) >= SIMILARITY_THRESHOLD
        );


        if (foundItem) {


            showFeedback(true);


            foundItem.found = true;

            // AANGEPAST: Gebruik R2_R3_R4_BONUS_SECONDS
            const secondsGained = R2_R3_R4_BONUS_SECONDS;


            // *** ZORG DAT DE ANIMATIE HIER WORDT GETRIGGERD ***
            showBonusFeedback(activePlayerIndex, secondsGained);

            updateSeconds(activePlayerIndex, secondsGained);

            // NIEUW: Als de speler een antwoord geeft (en het is goed), reset de attempts zodat de ronde kan doorgaan
            currentSetAttempts = [];


            updatePuzzleDisplay();


            const solvedCount = currentPuzzleSet.filter(p => p.found).length;

            if (solvedCount < 3) {


                setTimeout(() => {

                    if (!isTimerRunning) startTimer(activePlayerIndex);

                }, 50);


            }


        } else {


            showFeedback(false);

            // FIX: Geen automatische pas na fout antwoord in R2/R3/R4. Speler mag blijven proberen.
            // We voegen de speler NIET toe aan currentSetAttempts, tenzij hij daadwerkelijk PAS klikt.

            setTimeout(() => {
                // Herstart de klok zodat de speler door kan gaan
                if (!isTimerRunning) startTimer(activePlayerIndex);
            }, 1000);


        }


        inputAnswer.value = '';

        inputAnswer.focus();

    }


    function nextPuzzleSet() {
        currentR2SetCount++; // FIX: Teller verhoogt hier!

        if (currentR2SetCount >= players.length) {
            // Einde van de ronde
            hideAllGameAreas();
            questionText.style.display = 'block';
            questionText.textContent = "Einde van Ronde 2.";
            btnStartRound3.style.display = 'inline-block';
        } else {
            // Door naar de volgende set
            currentPuzzleSetIndex++;
            loadNewPuzzle();
        }

    }


    function showPuzzleAnswers() {

        if (!currentPuzzleSet) return;

        stopTimer();


        currentPuzzleSet.forEach(p => p.found = true);


        updatePuzzleDisplay();

        currentSetAttempts = [...players.map(p => p.originalIndex)]; // Iedereen heeft geprobeerd

        questionText.textContent = "Antwoorden getoond! Druk op 'Volgende Puzzel'.";


        btnShowPuzzleAnswers.style.display = 'none';
        btnCheckAnswer.style.display = 'none';
        inputAnswer.style.display = 'none';
        // btnPas.style.display = 'none'; // VERWIJDERD

        // Toon de Next knop; de controle of de ronde eindigt gebeurt in nextPuzzleSet
        btnNextPuzzle.style.display = 'inline-block';
        activePlayerIndex = getNextStartingPlayerIndex(2);
        renderPlayers();
    }


    function setupRound3() {

        currentRound = 3;

        currentOpenDeurIndex = 0;
        currentR3QuestionCount = 0; // FIX: Reset teller
        currentSetAttempts = []; // NIEUW: Reset attempts

        activePlayerIndex = getNextStartingPlayerIndex(3);


        btnStartRound4.style.display = 'none';


        roundTitle.textContent = `Ronde 3: Open Deur (Beloning: +${R2_R3_R4_BONUS_SECONDS} sec)`; // VERBETERING: Ronde naam tonen


        const fullPool = shuffleArray([...quizData.ronde3_openDeur]);

        shuffleArray(fullPool);


        const totalQuestionsNeeded = players.length;

        activeOpenDeurQuestions = fullPool.slice(0, totalQuestionsNeeded);


        if (activeOpenDeurQuestions.length < totalQuestionsNeeded) {

            alert(`Niet genoeg Open Deur vragen beschikbaar in de data (${fullPool.length}). Er zijn ${totalQuestionsNeeded} nodig. Door naar de volgende ronde.`);

            btnStartRound4.style.display = 'inline-block';

            return;

        }


        hideAllGameAreas();

        opendeurDisplayArea.style.display = 'block';
        questionText.style.display = 'block';
        questionCounter.style.display = 'block'; // VERBETERING: Toon teller


        inputAnswer.style.display = 'inline-block';
        btnCheckAnswer.style.display = 'inline-block';
        btnCheckAnswer.textContent = "Check Trefwoord";

        // btnPas.style.display = 'inline-block'; // VERWIJDERD


        loadOpenDeur();


        inputAnswer.disabled = true;


        timerPlayerIndex = activePlayerIndex;


        stopTimer();

        renderPlayers();

        inputAnswer.value = "";

        inputAnswer.focus();

    }


    function loadOpenDeur() {

        const nextStarterIndex = getNextStartingPlayerIndex(3);

        // NIEUWE LOGICA: Controleer of alle vragen gespeeld zijn
        if (currentR3QuestionCount >= players.length) {
            hideAllGameAreas();
            questionText.style.display = 'block';
            questionText.textContent = "Einde van Ronde 3.";
            btnStartRound4.style.display = 'inline-block';
            return;
        }

        // FIX: currentOpenDeurIndex moet altijd gelijk zijn aan currentR3QuestionCount
        currentOpenDeurIndex = currentR3QuestionCount;

        if (currentOpenDeurIndex >= activeOpenDeurQuestions.length) {
            // Als er geen volgende vraag is, forceren we het einde.
            currentR3QuestionCount = players.length;
            hideAllGameAreas();
            questionText.textContent = "Einde van Ronde 3.";
            btnStartRound4.style.display = 'inline-block';
            return;
        }

        activePlayerIndex = nextStarterIndex;
        currentSetAttempts = []; // NIEUW: Reset attempts voor de nieuwe vraag


        roundTitle.textContent = `Ronde 3: Open Deur (Beloning: +${R2_R3_R4_BONUS_SECONDS} sec)`; // VERBETERING: Ronde naam tonen

        activeOpenDeur = activeOpenDeurQuestions[currentOpenDeurIndex];


        // AANGEPAST: Toon de nieuwe beloning voor Ronde 3 (+40 SECONDEN)
        questionCounter.innerHTML = `Vraag ${currentR3QuestionCount + 1} / ${players.length} (Beloning: <strong>+${R2_R3_R4_BONUS_SECONDS} SECONDEN</strong> per trefwoord)`;


        questionText.textContent = "Wat weet je over...";


        opendeurSubject.textContent = activeOpenDeur.subject;


        const questionIdElement = document.getElementById('question-id');
        questionIdElement.style.display = 'block';

        formatAndDisplayIDs([activeOpenDeur.id]);


        updateOpenDeurState();


        opendeurSubject.classList.add('blurred-subject');


        btnCheckAnswer.textContent = "Check Trefwoord";

        btnNextOpenDeur.style.display = 'none';

        btnShowOpenDeurAnswers.style.display = 'inline-block';


        inputAnswer.style.display = 'inline-block';

        btnCheckAnswer.style.display = 'inline-block';


        inputAnswer.disabled = true;


        timerPlayerIndex = activePlayerIndex;


        stopTimer();

        renderPlayers();

        inputAnswer.value = "";

        inputAnswer.focus();

    }


    function updateOpenDeurState(showAll = false) {

        const container = document.getElementById('opendeur-keywords-container');


        if (!activeOpenDeur) return;

        roundTitle.textContent = `Ronde 3: Open Deur (Beloning: +${R2_R3_R4_BONUS_SECONDS} sec)`; // VERBETERING: Ronde naam tonen


        let keywordHTML = '';


        const keywordsToProcess = activeOpenDeur.keywords;

        keywordsToProcess.forEach(keywordObj => {
            const isFound = keywordObj.found || showAll;
            const displayClass = isFound ? 'found' : '';
            const displayText = isFound ? keywordObj.word : '???';

            keywordHTML += `<div class="opendeur-keyword ${displayClass}">${displayText}</div>`;
        });

        container.innerHTML = keywordHTML;


        if (activeOpenDeur.keywords.every(k => k.found)) {

            questionText.textContent = `OPGELOST! Druk op 'Volgende Vraag'.`;

            btnCheckAnswer.style.display = 'none';
            inputAnswer.style.display = 'none';
            // btnPas.style.display = 'none'; // VERWIJDERD

            stopTimer();

            opendeurSubject.classList.remove('blurred-subject');

            currentSetAttempts = [...players.map(p => p.originalIndex)]; // Iedereen heeft geprobeerd

            // Toon altijd de Next knop; de controle of de ronde eindigt gebeurt in nextOpenDeur
            btnNextOpenDeur.style.display = 'inline-block';
            activePlayerIndex = getNextStartingPlayerIndex(3);
            renderPlayers();
        }

    }


    function checkRound3Answer() {


        const userAnswer = inputAnswer.value.toLowerCase().trim();

        if (!isTimerRunning || !activeOpenDeur || userAnswer === "") return;


        const foundKeyword = activeOpenDeur.keywords.find(k =>
            stringSimilarity(k.word, userAnswer) >= SIMILARITY_THRESHOLD && !k.found
        );


        if (foundKeyword) {


            showFeedback(true);

            foundKeyword.found = true;

            // AANGEPAAST: Gebruik R2_R3_R4_BONUS_SECONDS
            const secondsGained = R2_R3_R4_BONUS_SECONDS;

            // *** ZORG DAT DE ANIMATIE HIER WORDT GETRIGGERD ***
            showBonusFeedback(activePlayerIndex, secondsGained);

            updateSeconds(activePlayerIndex, secondsGained);

            // NIEUW: Als de speler een antwoord geeft (en het is goed), reset de attempts zodat de ronde kan doorgaan
            currentSetAttempts = [];

            updateOpenDeurState();


            opendeurSubject.classList.remove('blurred-subject');


            setTimeout(() => {

                if (!isTimerRunning) startTimer(activePlayerIndex);

            }, 50);

        } else {


            showFeedback(false);

            // FIX: Geen automatische pas na fout antwoord in R2/R3/R4. Speler mag blijven proberen.
            // We voegen de speler NIET toe aan currentSetAttempts, tenzij hij daadwerkelijk PAS klikt.

            setTimeout(() => {
                // Herstart de klok zodat de speler door kan gaan
                if (!isTimerRunning) startTimer(activePlayerIndex);
            }, 1000);


        }

        inputAnswer.value = "";

        inputAnswer.focus();

    }

    function nextOpenDeur() {
        currentR3QuestionCount++; // FIX: Teller verhoogt hier!

        if (currentR3QuestionCount >= players.length) {
            // Einde van de ronde
            hideAllGameAreas();
            questionText.style.display = 'block';
            questionText.textContent = "Einde van Ronde 3.";
            btnStartRound4.style.display = 'inline-block';
        } else {
            // Door naar de volgende vraag
            currentOpenDeurIndex++;
            loadOpenDeur();
        }

    }


    function showOpenDeurAnswers() {

        if (!activeOpenDeur) return;

        stopTimer();

        activeOpenDeur.keywords.forEach(k => k.found = true);

        updateOpenDeurState(true);


        opendeurSubject.classList.remove('blurred-subject');

        currentSetAttempts = [...players.map(p => p.originalIndex)]; // Iedereen heeft geprobeerd

        questionText.textContent = `Antwoorden getoond. Druk op 'Volgende Vraag'.`;


        btnShowOpenDeurAnswers.style.display = 'none';
        btnCheckAnswer.style.display = 'none';
        inputAnswer.style.display = 'none';
        // btnPas.style.display = 'none'; // VERWIJDERD

        // Toon de Next knop; de controle of de ronde eindigt gebeurt in nextOpenDeur
        btnNextOpenDeur.style.display = 'inline-block';
        activePlayerIndex = getNextStartingPlayerIndex(3);
        renderPlayers();
    }


    let currentMemoryList = 0;


    function setupRound4() {

        currentRound = 4;

        currentMemoryList = 0;
        currentR4PlayerCount = 0; // FIX: Reset teller
        currentSetAttempts = []; // NIEUW: Reset attempts


        activePlayerIndex = getNextStartingPlayerIndex(4);


        btnStartFinale.style.display = 'none';

        roundTitle.textContent = `Ronde 4: Het Geheugen (Beloning: +${R2_R3_R4_BONUS_SECONDS} sec)`; // VERBETERING: Ronde naam tonen


        if (R4_FULL_SHUFFLED_POOL.length === 0) {

            R4_FULL_SHUFFLED_POOL = shuffleArray([...quizData.ronde4_geheugen]);

            R4_POOL_INDEX = 0;

        } else {

            R4_POOL_INDEX = 0;

        }


        hideAllGameAreas();

        geheugenDisplayArea.style.display = 'block';
        questionText.style.display = 'block';
        questionCounter.style.display = 'block'; // VERBETERING: Toon teller
        questionIdElement.style.display = 'block';


        inputAnswer.style.display = 'inline-block';
        btnCheckAnswer.style.display = 'inline-block';
        btnCheckAnswer.textContent = "Check Aanvulling";

        // btnPas.style.display = 'inline-block'; // VERWIJDERD


        loadMemoryQuestion();

    }


    function loadMemoryQuestion() {

        const nextStarterIndex = getNextStartingPlayerIndex(4);

        // NIEUWE LOGICA: Controleer of alle beurten gespeeld zijn
        if (currentR4PlayerCount >= players.length) {
            hideAllGameAreas();
            questionText.style.display = 'block';
            questionText.textContent = "Einde van Ronde 4! Druk op 'START DE FINALE'.";
            btnStartFinale.style.display = 'inline-block';
            puzzleIdsElement.style.display = 'none';
            return;
        }

        // FIX: currentMemoryList moet altijd gelijk zijn aan currentR4PlayerCount
        currentMemoryList = currentR4PlayerCount;

        if (currentMemoryList * MEMORY_QUESTIONS_PER_LIST >= R4_FULL_SHUFFLED_POOL.length) {
            // Als er niet genoeg vragen meer zijn voor een volledige beurt, forceren we het einde
            currentR4PlayerCount = players.length;
            hideAllGameAreas();
            questionText.style.display = 'block';
            questionText.textContent = "Ronde 4 gestopt wegens te weinig vragen. Druk op 'START DE FINALE'.";
            btnStartFinale.style.display = 'inline-block';
            return;
        }

        activePlayerIndex = nextStarterIndex;
        currentSetAttempts = []; // NIEUW: Reset attempts voor de nieuwe beurt


        roundTitle.textContent = `Ronde 4: Het Geheugen (Beloning: +${R2_R3_R4_BONUS_SECONDS} sec)`; // VERBETERING: Ronde naam tonen


        const fullPoolLength = R4_FULL_SHUFFLED_POOL.length;

        let currentSet = [];

        R4_POOL_INDEX = currentMemoryList * MEMORY_QUESTIONS_PER_LIST;

        for (let i = 0; i < MEMORY_QUESTIONS_PER_LIST; i++) {

            const poolIndex = R4_POOL_INDEX + i;
            const q = R4_FULL_SHUFFLED_POOL[poolIndex];


            currentSet.push({

                q1: q.q1,

                a: q.a,

                found: false,

                id: q.id

            });
        }

        activeRound4Questions = currentSet;


        geheugenBoard.classList.remove('answers-shown');
        geheugenBoard.style.removeProperty('filter');


        // AANGEPAAST: Toon de nieuwe beloning voor Ronde 4 (+40 SECONDEN)
        questionCounter.innerHTML = `Beurt ${currentR4PlayerCount + 1} / ${players.length} (Speler: ${players.find(p => p.originalIndex === activePlayerIndex).name}) (Beloning: <strong>+${R2_R3_R4_BONUS_SECONDS} SECONDEN</strong> per juist antwoord)`;
        questionIdElement.textContent = `Gevonden: 0 / ${MEMORY_QUESTIONS_PER_LIST}`; // Reset gevonden teller

        questionText.textContent = `Vul aan...`;


        updateMemoryDisplay();


        const currentR4IDs = activeRound4Questions.map(q => q.id);

        formatAndDisplayIDs(currentR4IDs);


        btnShowGeheugenAnswers.style.display = 'inline-block';

        btnNextGeheugenSpeler.style.display = 'none';

        btnStartFinale.style.display = 'none';


        inputAnswer.style.display = 'inline-block';

        btnCheckAnswer.style.display = 'inline-block';


        inputAnswer.disabled = true;


        stopTimer();

        renderPlayers();

        inputAnswer.value = "";

        inputAnswer.focus();

    }


    function updateMemoryDisplay(showAll = false) {

        const foundCount = activeRound4Questions.filter(q => q.found).length;


        roundTitle.textContent = `Ronde 4: Het Geheugen (Beloning: +${R2_R3_R4_BONUS_SECONDS} sec)`; // VERBETERING: Ronde naam tonen


        // AANGEPAAST: Toon de nieuwe beloning voor Ronde 4 (+40 SECONDEN)
        questionCounter.innerHTML = `Beurt ${currentR4PlayerCount + 1} / ${players.length} (Speler: ${players.find(p => p.originalIndex === activePlayerIndex).name}) (Beloning: <strong>+${R2_R3_R4_BONUS_SECONDS} SECONDEN</strong> per juist antwoord)`;
        questionIdElement.textContent = `Gevonden: ${foundCount} / ${MEMORY_QUESTIONS_PER_LIST}`;

        questionText.textContent = `Vul aan...`;


        geheugenBoard.innerHTML = activeRound4Questions.map((q, index) => {

            const isFound = q.found || showAll;

            const displayClass = isFound ? 'found' : '';

            const answerText = isFound ? q.a : '...?';

            return `

                <li class="geheugen-item ${displayClass}">

                    <span>${index + 1}. <strong>${q.q1}</strong>...</span>

                    <span class="geheugen-antwoord">${answerText}</span>

                </li>

            `;

        }).join('');


        if (foundCount === MEMORY_QUESTIONS_PER_LIST) {

            stopTimer();

            showFeedback(true);


            questionText.textContent = "Opgelost! Druk op 'Volgende Speler'.";

            btnShowGeheugenAnswers.style.display = 'none';

            btnCheckAnswer.style.display = 'none';
            inputAnswer.style.display = 'none';
            // btnPas.style.display = 'none'; // VERWIJDERD

            currentSetAttempts = [...players.map(p => p.originalIndex)]; // Iedereen heeft geprobeerd

            // Toon de Next knop; de controle of de ronde eindigt gebeurt in nextGeheugenSpeler
            btnNextGeheugenSpeler.style.display = 'inline-block';
            activePlayerIndex = getNextStartingPlayerIndex(4);
            renderPlayers();
        }

    }


    function checkRound4Answer() {


        if (!isTimerRunning) {
            return;
        }


        const userAnswer = inputAnswer.value.toLowerCase().trim();


        const foundItem = activeRound4Questions.find(q =>
            !q.found && stringSimilarity(q.a, userAnswer) >= SIMILARITY_THRESHOLD
        );


        if (foundItem) {


            showFeedback(true);

            foundItem.found = true;

            // AANGEPAAST: Gebruik R2_R3_R4_BONUS_SECONDS
            const secondsGained = R2_R3_R4_BONUS_SECONDS;

            // *** ZORG DAT DE ANIMATIE HIER WORDT GETRIGGERD ***
            showBonusFeedback(activePlayerIndex, secondsGained);

            updateSeconds(activePlayerIndex, secondsGained);

            // NIEUW: Als de speler een antwoord geeft (en het is goed), reset de attempts zodat de ronde kan doorgaan
            currentSetAttempts = [];


            updateMemoryDisplay();


        } else {


            showFeedback(false);

            // FIX: Geen automatische pas na fout antwoord in R2/R3/R4. Speler mag blijven proberen.
            // We voegen de speler NIET toe aan currentSetAttempts, tenzij hij daadwerkelijk PAS klikt.

            setTimeout(() => {
                // Herstart de klok zodat de speler door kan gaan
                if (!isTimerRunning) startTimer(activePlayerIndex);
            }, 1000);


        }


        setTimeout(() => {

            if (!isTimerRunning) startTimer(activePlayerIndex);

        }, 50);


        inputAnswer.value = '';

        inputAnswer.focus();

    }


    function showMemoryAnswers() {


        activeRound4Questions.forEach(q => q.found = true);


        geheugenBoard.classList.add('answers-shown');
        geheugenBoard.style.removeProperty('filter');

        updateMemoryDisplay(true);

        currentSetAttempts = [...players.map(p => p.originalIndex)]; // Iedereen heeft geprobeerd

        questionText.textContent = `Antwoorden getoond! Druk op 'Volgende Speler'.`;


        btnShowGeheugenAnswers.style.display = 'none';
        btnCheckAnswer.style.display = 'none';
        inputAnswer.style.display = 'none';
        // btnPas.style.display = 'none'; // VERWIJDERD

        // Toon de Next knop; de controle of de ronde eindigt gebeurt in nextGeheugenSpeler
        btnNextGeheugenSpeler.style.display = 'inline-block';
        activePlayerIndex = getNextStartingPlayerIndex(4);
        renderPlayers();
    }


    function nextGeheugenSpeler() {
        currentR4PlayerCount++; // FIX: Teller verhoogt hier!

        if (currentR4PlayerCount >= players.length) {
            // Einde van de ronde
            hideAllGameAreas();
            questionText.style.display = 'block';
            questionText.textContent = "Einde van Ronde 4! Druk op 'START DE FINALE'.";
            btnStartFinale.style.display = 'inline-block';
        } else {
            // Door naar de volgende speler/set
            currentMemoryList++; // De index voor het laden van de vragen mag wel omhoog
            loadMemoryQuestion();
        }

    }


    // ==========================================================
    // RONDE 5 FINALE FUNCTIES
    // ==========================================================


    function setupFinale() {

        currentRound = 5;

        currentFinaleQuestionIndex = 0;


        btnStartFinale.style.display = 'none';

        roundTitle.textContent = "Ronde 5: De Finale"; // VERBETERING: Ronde naam tonen


    // Bepaal de top 2 spelers op basis van seconden (hoge score wint)
    const topTwoPlayers = [...players].sort((a, b) => b.seconds - a.seconds).slice(0, 2);

    // Filter de oorspronkelijke 'players' array om de finalisten in hun originele (vaste) volgorde te behouden
    finalists = players
        .filter(p => topTwoPlayers.some(topP => topP.originalIndex === p.originalIndex))
        .map(p => ({
            player: p,
            originalIndex: p.originalIndex
        }));

    


        if (finalists.length < 2) {

            alert("Niet genoeg spelers voor de finale.");

            return;

        }


        const fullPool = shuffleArray([...quizData.ronde5_finale]);
        activeFinaleQuestions = fullPool.slice(0, Math.min(fullPool.length, FINALE_QUESTIONS));


        btnFinaleShow.style.display = 'inline-block';
        btnFinaleNext.style.display = 'none';


        const lowestScorePlayer = finalists.sort((a, b) => a.player.seconds - b.player.seconds)[0];

        activePlayerIndex = lowestScorePlayer.player.originalIndex;

        activeFinalistIndex = finalists.findIndex(f => f.player.originalIndex === activePlayerIndex);


        hideAllGameAreas();

        document.getElementById('finale-display-area').style.display = 'block';
        questionText.style.display = 'block';
        questionCounter.style.display = 'block'; // VERBETERING: Toon teller


        inputAnswer.style.display = 'inline-block';

        btnCheckAnswer.style.display = 'inline-block';
        btnCheckAnswer.textContent = "Check Antwoord";

        btnFinaleShow.style.display = 'inline-block';

        btnFinaleNext.style.display = 'none';

        // btnPas.style.display = 'inline-block'; // VERWIJDERD


        inputAnswer.disabled = true;


        loadFinaleQuestion();

    }


    function loadFinaleQuestion() {

        if (currentFinaleQuestionIndex >= activeFinaleQuestions.length) {

            const winnerPlayer = finalists.sort((a, b) => b.player.seconds - a.player.seconds)[0].player;
            showFinaleWinner(winnerPlayer);
            return;
        }

        currentFinaleQuestion = activeFinaleQuestions[currentFinaleQuestionIndex];
        currentFinaleQuestion.keywords.forEach(k => k.found = false);


        document.getElementById('finale-subject').textContent = currentFinaleQuestion.subject;
        document.getElementById('finale-subject').classList.add('blurred-subject');


        questionCounter.innerHTML = `FINALE Vraag ${currentFinaleQuestionIndex + 1} / Aan de beurt: ${finalists[activeFinalistIndex].player.name}`;
        questionText.textContent = `Zoek de 5 trefwoorden die bij '${currentFinaleQuestion.subject}' horen.`;

        const finaleKeywordsContainer = document.getElementById('finale-keywords-container');
        finaleKeywordsContainer.innerHTML = currentFinaleQuestion.keywords.map(k =>
            `<div class="finale-keyword" data-word="${k.word}">???</div>`
        ).join('');


        formatAndDisplayIDs([currentFinaleQuestion.id]);


        btnFinaleShow.style.display = 'inline-block';
        btnFinaleNext.style.display = 'none';
        btnCheckAnswer.style.display = 'inline-block';
        inputAnswer.style.display = 'inline-block';
        // btnPas.style.display = 'inline-block'; // VERWIJDERD

        inputAnswer.disabled = true;
        inputAnswer.value = '';
        inputAnswer.focus();

        stopTimer();
        renderPlayers();
    }


    function checkFinaleAnswer() {


        const userAnswer = inputAnswer.value.toLowerCase().trim();

        const currentKeywords = currentFinaleQuestion.keywords;


        const foundKeyword = currentKeywords.find(k =>
            stringSimilarity(k.word, userAnswer) >= SIMILARITY_THRESHOLD && !k.found
        );


        if (foundKeyword) {


            showFeedback(true);

            foundKeyword.found = true;


            // LOGICA: Trek seconden af van de TEGENSTANDER (bij juist antwoord)
            const opponent = players.find(p => p.originalIndex !== activePlayerIndex && finalists.some(f => f.player.originalIndex === p.originalIndex));

            if (opponent) {
                // Trek seconden af van de TEGENSTANDER (bij juist antwoord)
                // *** ZORG DAT DE ANIMATIE HIER WORDT GETRIGGERD (TEGENSTANDER) ***
                showBonusFeedback(opponent.originalIndex, -R5_OPPONENT_PENALTY_SECONDS); 
                updateSeconds(opponent.originalIndex, -R5_OPPONENT_PENALTY_SECONDS);
            }


            document.getElementById('finale-subject').classList.remove('blurred-subject');


            const keywordElements = document.getElementById('finale-keywords-container').querySelectorAll('.finale-keyword');


            const correctElement = Array.from(keywordElements).find(el => el.dataset.word.toLowerCase() === foundKeyword.word.toLowerCase());


            if (correctElement) {

                correctElement.classList.add('found');

                correctElement.textContent = foundKeyword.word;

            }


            if (currentKeywords.every(k => k.found)) {

                questionText.textContent = `OPGELOST! Druk op 'Volgende Vraag'.`;

                btnFinaleNext.style.display = 'inline-block';

                btnCheckAnswer.style.display = 'none';

                inputAnswer.style.display = 'none';

                // btnPas.style.display = 'none'; // VERWIJDERD

                btnFinaleShow.style.display = 'none';


                stopTimer();
            }


            setTimeout(() => {

                if (!currentKeywords.every(k => k.found) && !isTimerRunning && !isGameOver) {
                    startTimer(activePlayerIndex);
                }
            }, 50);


        } else {


            showFeedback(false);


            // LOGICA: Bij een fout antwoord in de Finale gebeurt er niets met de score van de tegenstander, enkel de melding wordt aangepast.

            questionCounter.innerHTML = `FINALE Vraag ${currentFinaleQuestionIndex + 1} / Aan de beurt: ${finalists[activeFinalistIndex].player.name} (Fout. Blijf proberen.)`;


            setTimeout(() => {

                if (!isTimerRunning) startTimer(activePlayerIndex);

            }, 50);

        }

        inputAnswer.value = '';

        inputAnswer.focus();

    }


    function showFinaleAnswers() {

        stopTimer();

        currentFinaleQuestion.keywords.forEach(k => k.found = true);


        document.getElementById('finale-subject').classList.remove('blurred-subject');


        const keywordElements = document.getElementById('finale-keywords-container').querySelectorAll('.finale-keyword');

        for (const el of keywordElements) {

            el.classList.add('found');

            el.textContent = el.dataset.word;

        }


        questionText.textContent = `Antwoorden getoond. Druk op 'Volgende Vraag'.`;


        btnFinaleShow.style.display = 'none';
        btnFinaleNext.style.display = 'inline-block';
        btnCheckAnswer.style.display = 'none';
        inputAnswer.style.display = 'none';
        // btnPas.style.display = 'none'; // VERWIJDERD

    }


    function nextFinaleQuestion() {


        const p1 = finalists[0].player;
        const p2 = finalists[1].player;


        if (p1.seconds <= 0 || p2.seconds <= 0) {

            const winnerPlayer = finalists.map(f => f.player).find(p => p.seconds > 0);
            if (winnerPlayer) {
                showFinaleWinner(winnerPlayer);
                return;
            }

        }

        let lowestScorePlayer;
        if (p1.seconds < p2.seconds) {
            lowestScorePlayer = p1;
        } else if (p2.seconds < p1.seconds) {
            lowestScorePlayer = p2;
        } else {

            // Als de scores gelijk zijn, start de speler die de vorige vraag NIET had
            lowestScorePlayer = finalists.find(f => f.player.originalIndex !== activePlayerIndex)?.player || p1;
        }


        currentFinaleQuestionIndex++;


        if (currentFinaleQuestionIndex >= activeFinaleQuestions.length) {

            const winnerPlayer = finalists.sort((a, b) => b.player.seconds - a.seconds)[0].player;
            showFinaleWinner(winnerPlayer);
            return;
        }


        activeFinalistIndex = finalists.findIndex(f => f.player.originalIndex === lowestScorePlayer.originalIndex);
        activePlayerIndex = lowestScorePlayer.originalIndex;


        loadFinaleQuestion();
    }


    playerContainer.addEventListener('click', (event) => {

        const card = event.target.closest('.player-card');

        if (!card) return;


        const clickedIndex = parseInt(card.dataset.playerIndex);


        if (currentRound === 1) {
            if (event.target.classList.contains('player-timer-btn')) {
                toggleTimer(clickedIndex);
            } else {
                activePlayerIndex = clickedIndex;
                renderPlayers();
            }
        } else if (currentRound >= 2 && currentRound <= 5) {

            toggleTimer(clickedIndex);
        } else {

            activePlayerIndex = clickedIndex;
            renderPlayers();
        }
    });


    btnCheckAnswer.addEventListener('click', checkAnswer);


    btnCheckAnswer.addEventListener('click', checkAnswer);


    inputAnswer.addEventListener('keyup', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            checkAnswer();

            setTimeout(() => {
                inputAnswer.focus();
            }, 50);
        }
    });


    document.addEventListener('keydown', (event) => {
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
            return;
        }

        if (event.key.toLowerCase() === 'x') {

            if (currentRound >= 2 && currentRound <= 5) {

                if (activePlayerIndex !== null && players.find(p => p.originalIndex === activePlayerIndex)) {
                    toggleTimer(activePlayerIndex);
                    event.preventDefault();
                }
            }
        }
    });


    // Knoppen zijn al correct
    document.getElementById('start-round-2').addEventListener('click', setupRound2);
    document.getElementById('start-round-3').addEventListener('click', setupRound3);
    document.getElementById('start-round-4').addEventListener('click', setupRound4);
    document.getElementById('start-finale').addEventListener('click', setupFinale);

    // De volgende event listeners zijn verwijderd omdat de knoppen uit de HTML zijn:
    // document.getElementById('test-ronde-2').addEventListener('click', () => initializeGame(2));
    // document.getElementById('test-ronde-3').addEventListener('click', () => initializeGame(3));
    // document.getElementById('test-ronde-4').addEventListener('click', () => initializeGame(4));
    
    document.getElementById('start-round-1').addEventListener('click', startGameR1);

    document.getElementById('next-puzzle').addEventListener('click', nextPuzzleSet);
    document.getElementById('show-puzzle-answers').addEventListener('click', showPuzzleAnswers);

    document.getElementById('next-opendeur').addEventListener('click', nextOpenDeur);
    document.getElementById('show-opendeur-answers').addEventListener('click', showOpenDeurAnswers);

    document.getElementById('next-geheugen-speler').addEventListener('click', nextGeheugenSpeler);
    document.getElementById('show-geheugen-answers').addEventListener('click', showMemoryAnswers);

    document.getElementById('btn-finale-next').addEventListener('click', nextFinaleQuestion);
    document.getElementById('btn-finale-show').addEventListener('click', showFinaleAnswers);

    // btnPas.addEventListener('click', pasDeBeurt); // VERWIJDERD


    // Spelmeester Controles
    btnWrongAnswer.addEventListener('click', () => {
        const amount = -20;
        updateSeconds(activePlayerIndex, amount);
        showBonusFeedback(activePlayerIndex, amount); // Toon de malus visueel

        if (currentRound >= 2 && currentRound <= 4) {

            // Zorg dat de klok herstart als deze gestopt was (bijvoorbeeld door GM handeling)
            if (!isTimerRunning && players.find(p => p.originalIndex === activePlayerIndex)?.seconds > 0) {
                startTimer(activePlayerIndex);
            }
        }
    });
    btnAdd10.addEventListener('click', () => {
        const amount = 10;
        updateSeconds(activePlayerIndex, amount);
        showBonusFeedback(activePlayerIndex, amount); // Toon de bonus visueel
    });
    btnAdd20.addEventListener('click', () => {
        const amount = 20;
        updateSeconds(activePlayerIndex, amount);
        showBonusFeedback(activePlayerIndex, amount); // Toon de bonus visueel
    });


</script>

</body>

</html>
